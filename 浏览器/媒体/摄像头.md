


# 拍照


### 一、代码实现

```vue
   <template>
        <video ref={videoRef}></video>
        <div>
          <button onClick={startCamera} style={{ marginRight: '10px' }}>
            开启摄像头
          </button>
          <button onClick={handleSnap} disabled={!stream}>
            拍照
          </button>
        </div>
        <div style={{ marginTop: '10px' }}>
          <canvas
            id="canvas"
            style={{
              width: '100px',
              height: '75px',
              border: '1px solid #ccc'
            }}></canvas>
        </div>
   </template>
```

```vue
<script>
// 启动摄像头
  const startCamera = () => {
  // 接收使用一个设备
    navigator.mediaDevices
      .getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
		  facingMode: { exact: 'environment' } // 后置 exact:user为前置
        },
        audio: false
      })
      .then((stream) => {
        const videoElement = videoRef.current
        if (videoElement) {
          videoElement.srcObject = stream
          setStream(stream)
          // 确保视频播放
          videoElement.play().catch((e) => {
            console.error('视频播放失败:', e)
          })
        }
      })
      .catch((error) => {
        console.error('无法访问摄像头：', error)
        alert(`无法访问摄像头：${error.message}`)
      })
  }
  
    // 拍照功能

  const handleSnap = () => {
    const canvas = document.getElementById('canvas') as HTMLCanvasElement
    const video = videoRef.current
    const ctx = canvas.getContext('2d')
    if (video && ctx && video.videoWidth > 0) {
      // 设置canvas尺寸与视频一致
      canvas.width = video.videoWidth
      canvas.height = video.videoHeight
      // ctx.filter：给canvas添加滤镜
      // 绘制当前视频帧到canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height)
      // 可以获取图片数据
      const imageData = canvas.toDataURL('image/png')
      console.log('图片数据:', imageData) // base64
      // 或者下载图片
      // const link = document.createElement('a')
      // link.download = 'photo.png'
      // link.href = imageData
      // link.click()
    }

  }
</script>
```
获取摄像头列表
```javascript
	
	// 获取设备列表
	const devices = await navigator.mediaDevices.enumerateDevices();
	
	
	// 筛选出摄像头设备
	const videoDevices = devices.filter(device => 
		device.kind === 'videoinput'
	);
	
    // 请求摄像头权限（部分浏览器需要）
	await navigator.mediaDevices.getUserMedia({ video: true });

	
```
切换摄像头
```javascript
    // 请求摄像头权限（部分浏览器需要）
	await navigator.mediaDevices.getUserMedia({ video: {deviceId:ids[stop].deviceId} });
```
停止摄像头流输出
```javascript
// 立即停止流，我们只需要权限
stream.getTracks().forEach(track => track.stop());
```

### 二、交互流程

window -> `getUserMedia`  →`调用摄像头设备` →获取设备数据流 `MediaStream` → 投到视频组件预览 `<video>`截取视频上的帧`<canvas>`

### 三、关键点

1. 开启摄像头，需要授权
2. 将摄像头的数据流，接入到video中
3. 使用canvas进行截图
	1. 接收video实例
	2. 绘制尺寸与video保持一直，或者自定义尺寸

### 四、常见问题与解决方案

1. **为什么在本地打不开？** `getUserMedia` 需要在 **HTTPS 或 localhost** 环境下才能使用。
2. **如何切换前后摄像头？** 使用 `facingMode` 参数：
- `"user"` → 前置摄像头
- `"environment"` → 后置摄像头（扫码常用）
1. **多摄像头选择** 通过 `navigator.mediaDevices.enumerateDevices()` 获取设备列表，再指定 `deviceId`。
	1. 先通过授权api，不要立刻投到video中，立刻投也行
	2. 提示选择摄像头，或者切换摄像头，重新获取媒体流，然后对接到video中
2. **用户拒绝权限** 浏览器会返回 `NotAllowedError`，需要提示用户手动开启权限。

### 五、进阶应用场景
- **扫码应用**：结合 `jsQR` 实现二维码识别。
- **人脸识别**：配合 TensorFlow.js 或 Face API。
- **视频会议**：WebRTC PeerConnection 实现实时通话。
- **滤镜/特效**：结合 WebGL / Three.js 实现 AR 效果。

### 六、总结

- 核心 API：`navigator.mediaDevices.getUserMedia`
- 运行环境：HTTPS / localhost
- `<video>` 用于播放，`<canvas>` 用于截图和处理
- 扩展应用：扫码、人脸识别、视频会议、AR 滤镜

只要理解了原理和 API，用浏览器摄像头开发各种功能都很简单


# 录像


## 一、代码

```html

<!DOCTYPE html>

<html>
<head>
    <title>摄像头录像</title>
</head>

<body>
    <div>
        <video id="preview" autoplay playsinline></video>
        <div>
            <button id="startBtn">开始录制</button>
            <button id="stopBtn" disabled>停止录制</button>
            <button id="pauseBtn" disabled>暂停</button>
            <button id="resumeBtn" disabled>恢复</button>
        </div>
        <div>
            <h3>录制的视频:</h3>
            <video id="playback" controls></video>
        </div>
        <a id="downloadLink" style="display:none">下载视频</a>
    </div>
</body>

<script>

class CameraRecorder {
    constructor() {
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.stream = null;
        
        // DOM元素
        this.previewVideo = document.getElementById('preview');
        this.playbackVideo = document.getElementById('playback');
        this.downloadLink = document.getElementById('downloadLink');
        
        // 按钮
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.pauseBtn = document.getElementById('pauseBtn');
        this.resumeBtn = document.getElementById('resumeBtn');
        this.init();
    }

    async init() {

        try {
            // 请求摄像头权限
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user' // 或 'environment' 后置摄像头
                },
                audio: true
            });

            // 显示预览
            this.previewVideo.srcObject = this.stream;
            this.setupEventListeners();
        } catch (error) {
            console.error('获取摄像头失败:', error);
            alert('无法访问摄像头，请检查权限');

        }

    }

  

    setupEventListeners() {

        this.startBtn.addEventListener('click', () => this.startRecording());
        this.stopBtn.addEventListener('click', () => this.stopRecording());
        this.pauseBtn.addEventListener('click', () => this.pauseRecording());
        this.resumeBtn.addEventListener('click', () => this.resumeRecording());

    }


    startRecording() {

        // 重置
        this.recordedChunks = [];
        // 创建MediaRecorder
        const options = {
            mimeType: 'video/webm;codecs=vp9,opus',
            videoBitsPerSecond: 2500000 // 2.5 Mbps
        };

        try {

            this.mediaRecorder = new MediaRecorder(this.stream, options);
            // 数据可用时触发
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.datAa);
                }
            };

            // 录制停止时触发
            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, {
                    type: 'video/webm'
                });

                const url = URL.createObjectURL(blob);
                
                // 播放录制的视频
                this.playbackVideo.src = url;
                
                // 提供下载链接
                this.downloadLink.href = url;
                this.downloadLink.download = `recording-${Date.now()}.webm`;
                this.downloadLink.style.display = 'block';
                this.downloadLink.textContent = '下载视频';

            };

            // 开始录制
            this.mediaRecorder.start(100); // 每100ms收集一次数据

            // 更新按钮状态
            this.startBtn.disabled = true;
            this.stopBtn.disabled = false;
            this.pauseBtn.disabled = false;

            console.log('开始录制...');

        } catch (error) {
            console.error('录制失败:', error);
            alert('录制失败: ' + error.message);

        }

    }

  

    stopRecording() {

        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
            // 更新按钮状态
            this.startBtn.disabled = false;
            this.stopBtn.disabled = true;
            this.pauseBtn.disabled = true;
            this.resumeBtn.disabled = true;
            console.log('停止录制');

        }

    }

  

    pauseRecording() {

        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.pause();
            this.pauseBtn.disabled = true;
            this.resumeBtn.disabled = false;
            console.log('暂停录制');
        }

    }

  

    resumeRecording() {

        if (this.mediaRecorder && this.mediaRecorder.state === 'paused') {
            this.mediaRecorder.resume();
            this.pauseBtn.disabled = false;
            this.resumeBtn.disabled = true;
            console.log('恢复录制');

        }

    }

  

    // 释放摄像头资源

    stopCamera() {

        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.previewVideo.srcObject = null;

        }

    }

}

  

// 页面加载后初始化

window.addEventListener('DOMContentLoaded', () => {

    const recorder = new CameraRecorder();
    // 页面关闭前释放摄像头
    window.addEventListener('beforeunload', () => {
        recorder.stopCamera();
    });

});

</script>

</html>

```


### 步骤

1. 获取摄像头权限
2. 录制：`this.mediaRecorder = new MediaRecorder(this.stream, options);`, 媒体录制器api
	1. 流程：就像水龙头一样，开 -> 水桶接水 -> 关 -> 提桶走人
	2. 开始：定制数据流容器格式video/webm,音视频解码器组合codecs=`vp9`,`opus`，码率配置，通过strat方法,将数据流接到数组里，
	3. 暂停
	4. 继续
	5. 结束：提桶走人，生成video/webm数据格式
3. 获取到二进制视频源数据
4. 释放资源




## 二、相关配置

码率配置

``` javascript
// 高质量 (1080p)
const highQuality = {
    videoBitsPerSecond: 5000000, // 5 Mbps
    // 文件较大，画质优秀
};

// 中等质量 (720p)
const mediumQuality = {
    videoBitsPerSecond: 2500000, // 2.5 Mbps
    // 平衡画质和文件大小
};

// 低质量 (480p)
const lowQuality = {
    videoBitsPerSecond: 1000000, // 1 Mbps
    // 文件小，适合网络传输
};

// 自适应质量
const adaptiveQuality = {
    videoBitsPerSecond: 500000, // 最小 0.5 Mbps
    // 最大 2 Mbps
};

// 分别设置视频和音频的码率
const options = {
    audioBitsPerSecond: 128000,    // 音频: 128 kbps
    videoBitsPerSecond: 2500000,   // 视频: 2.5 Mbps
    // 总比特率: 约 2.63 Mbps
};

```

检测浏览器支持的容器格式和解码配置

``` javascript
// VP8 + Opus (最广泛支持)
'video/webm;codecs=vp8,opus'

// VP9 + Opus (更好压缩比)
'video/webm;codecs=vp9,opus'

// H.264 + AAC (MP4格式，兼容性更好)
'video/mp4;codecs=avc1.42E01E,mp4a.40.2'

// H.265 + AAC (更高效压缩)
'video/mp4;codecs=hvc1.1.6.L93.B0,mp4a.40.2'
```

``` javascript
function getSupportedMimeType() {
    const mimeTypes = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
        'video/webm;codecs=h264,opus',
        'video/webm'
    ];
    
    for (let mimeType of mimeTypes) {
        if (MediaRecorder.isTypeSupported(mimeType)) {
            console.log(`支持: ${mimeType}`);
            return mimeType;
        }
    }
    return 'video/webm'; // 默认值
}

const options = {
    mimeType: getSupportedMimeType()
};
```

## 三、实际应用示例

#### 根据分辨率自动设置比特率

```javascript

function getBitrateByResolution(width, height) {
    const pixels = width * height;
    
    if (pixels > 1920 * 1080) { // 2K以上
        return 8000000; // 8 Mbps
    } else if (pixels > 1280 * 720) { // 1080p
        return 5000000; // 5 Mbps
    } else if (pixels > 854 * 480) { // 720p
        return 2500000; // 2.5 Mbps
    } else { // 480p及以下
        return 1000000; // 1 Mbps
    }
}

async function getCameraSettings() {
    const stream = await navigator.mediaDevices.getUserMedia({ 
        video: true 
    });
    const track = stream.getVideoTracks()[0];
    const settings = track.getSettings();
    
    return {
        width: settings.width,
        height: settings.height,
        frameRate: settings.frameRate
    };
}

async function initRecorder() {
    const cameraSettings = await getCameraSettings();
    const bitrate = getBitrateByResolution(
        cameraSettings.width, 
        cameraSettings.height
    );
    
    const options = {
        mimeType: getSupportedMimeType(),
        videoBitsPerSecond: bitrate,
        audioBitsPerSecond: 128000
    };
    
    console.log(`分辨率: ${cameraSettings.width}x${cameraSettings.height}`);
    console.log(`比特率: ${bitrate / 1000000} Mbps`);
    console.log(`格式: ${options.mimeType}`);
    
    return options;
}

``` javascript
```

#### 平衡质量和文件大小


```javascript

const qualityProfiles = {
    'low': {
        mimeType: 'video/webm;codecs=vp8,opus',
        videoBitsPerSecond: 1000000,  // 1 Mbps
        audioBitsPerSecond: 64000     // 64 kbps
    },
    'medium': {
        mimeType: 'video/webm;codecs=vp9,opus',
        videoBitsPerSecond: 2500000,  // 2.5 Mbps
        audioBitsPerSecond: 128000    // 128 kbps
    },
    'high': {
        mimeType: 'video/webm;codecs=vp9,opus',
        videoBitsPerSecond: 5000000,  // 5 Mbps
        audioBitsPerSecond: 192000    // 192 kbps
    },
    'mobile': {
        mimeType: 'video/webm;codecs=vp8,opus',
        videoBitsPerSecond: 1500000,  // 1.5 Mbps
        audioBitsPerSecond: 96000,    // 96 kbps
        // 限制帧率节省电量
        video: {
            frameRate: { ideal: 24, max: 30 }
        }
    }
};

// 根据设备选择配置
function getProfileByDevice() {
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const connection = navigator.connection || navigator.mozConnection;
    
    if (isMobile) {
        return connection?.effectiveType === '4g' 
            ? qualityProfiles.medium 
            : qualityProfiles.mobile;
    }
    
    return qualityProfiles.high;
}
``` javascript
```
## 四、注意事项

### 1. 比特率参考标准

```text

视频会议: 500kbps - 2Mbps
屏幕录制: 1Mbps - 5Mbps
高清录像: 2.5Mbps - 10Mbps
4K录像: 20Mbps - 50Mbps

``` text
```

### 2. 格式兼容性检查

```javascript

// 检查特定格式是否支持
if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) {
    console.log('支持 VP9 + Opus');
}

// 检查比特率是否适用
const maxBitrate = 5000000; // 5 Mbps
const actualBitrate = Math.min(bitrate, maxBitrate);


``` 
### 3. 估算文件大小

``` javascript

function estimateFileSize(bitrate, durationSeconds) {
    // 总比特数 = 比特率 × 时间
    const totalBits = bitrate * durationSeconds;
    // 转换为 MB: 比特数 ÷ 8 ÷ 1024 ÷ 1024
    const fileSizeMB = totalBits / 8 / 1024 / 1024;
    
    console.log(`${durationSeconds}秒视频大约占用: ${fileSizeMB.toFixed(2)} MB`);
    return fileSizeMB;
}

// 示例：2.5 Mbps 录制1分钟
estimateFileSize(2500000, 60); // 约 17.90 MB
