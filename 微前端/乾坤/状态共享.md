### **方案一：通过 qiankun 全局状态通信 (官方推荐)**

#### 主应用：

**设置全局状态**：在主应用中初始化全局状态并注入 Token。

```javascript
// 主应用：src/actions.js
import { initGlobalState } from 'qiankun';

const initialState = { token: '主应用的Token' };
const actions = initGlobalState(initialState);

// 更新 Token 的方法（如登录后调用）
actions.setGlobalState({ token: 'new_token' });
```

**传递状态给子应用**：注册子应用时通过 `props` 传递 actions。

```
// 主应用：注册子应用
registerMicroApps([
  {
    name: '子应用名称',
    entry: '//子应用入口',
    container: '#container',
    activeRule: '/子应用路由',
    props: { actions }, // 传递 actions
  },
]);
```

#### 子应用：

**获取全局状态**：在子应用生命周期中接收 `props`，监听 Token 变化。

```
// 子应用：入口文件（如 main.js）
let globalActions;

export async function mount(props) {
  globalActions = props.actions;

  // 初始化时获取 Token
  const { token } = props.getGlobalState();
  setToken(token); // 存储到子应用的状态管理（如 Vuex/Redux）或请求拦截器

  // 监听 Token 变化
  props.onGlobalStateChange((state) => {
    setToken(state.token);
  }, true);
}
```

---

### **方案二：通过 localStorage / Cookie 共享**

#### 主应用：

**存储 Token**：登录后将 Token 存入 `localStorage` 或跨域 Cookie。

```
// 主应用：登录成功后
localStorage.setItem('token', '主应用Token');
// 或使用 Cookie（需处理跨域）
```

#### 子应用：

**读取 Token**：直接访问同一域名下的存储。

```
// 子应用：在请求拦截器或初始化时读取
const token = localStorage.getItem('token');
// 或从 Cookie 读取
```

#### 注意事项：

- **同源策略**：子应用需与主应用同域，否则需通过 `postMessage` 或 CORS 处理跨域。
- **安全性**：避免敏感信息明文存储，可结合加密或 HttpOnly Cookie。

---

### **方案三：通过 URL 参数传递**

#### 主应用：

**拼接 Token 到子应用 URL**：

```
// 主应用：跳转到子应用时携带 Token
window.history.pushState({}, '', '/子应用路由?token=主应用Token');
```

#### 子应用：

**解析 URL 参数**：

```
// 子应用：获取 URL 中的 Token
const urlParams = new URLSearchParams(window.location.search);
const token = urlParams.get('token');
```

#### 注意事项：

- **安全性差**：Token 暴露在 URL 中，存在泄露风险，不推荐生产环境使用。

  
  

### **方案四：shared**

给props传递store实例

```
// micro-app-main/src/shared/index.ts
import store from "./store";

class Shared {
  /**
   * 获取 Token
   */
  public getToken(): string {
    const state = store.getState();
    return state.token || "";
  }

  /**
   * 设置 Token
   */
  public setToken(token: string): void {
    // 将 token 的值记录在 store 中
    store.dispatch({
      type: "SET_TOKEN",
      payload: token
    });
  }
}

const shared = new Shared();
export default shared;
```

```
import {
  registerMicroApps,
  start,
} from "qiankun";
import shared from './shared'
const apps = [
  {
    name: "App1MicroApp",
    entry: '//localhost:9001',
    container: "#app1",
    activeRule: "/app1",
    props: {
      parentShared: shared
    }
  }
];

registerMicroApps(apps);
start();
```

---

### **最佳实践建议**

1. **优先使用全局状态通信**：方案一符合微前端设计理念，能动态响应 Token 变化。

**降级处理**：子应用独立运行时（非 qiankun 环境），可回退到 `localStorage` 或手动登录。

```
// 子应用：独立运行兼容
if (!window.__POWERED_BY_QIANKUN__) {
  const token = localStorage.getItem('token');
  if (!token) window.location.href = '主应用登录页';
}
```

**请求拦截器统一处理**：在子应用的 Axios/Fetch 拦截器中注入 Token。

```
// 子应用：src/utils/request.js
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${getToken()}`;
  return config;
});
```





## 实际上需要用到状态管理的场景


## Token共享

- 子应用直接读取主应用的Localstorage
- 子应用的Localstorage - key 做统一取名：项目名称 + key

## 是否qiankun环境

- 写到hooks和全局store中

```
if (window.__POWERED_BY_QIANKUN__) {
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```

## 路由跳转统一

1. 主应用将router对象传给子应用，子应用在微前端下跳转情况较少，直接用history.push()

## 子应用给主应用发送通知

- event-bus
- window.postMessage✅
- qiankun的initGlobalState✅